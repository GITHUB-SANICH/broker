
const bodyElement = document.body;
bodyElement.insertAdjacentHTML(
	"beforebegin",
	"<h3>БК - node.js + express</h3>"
);

{ //Заметки к урокам
	//bodyElement.insertAdjacentHTML(
	//	"beforebegin",
	//	"<hr><hr><hr><br><h3>Задания на тему JavaScript - Базовые понятия</h3><hr><hr><br>"
	//);

	/*Заметки к уроку "#2 – Установка и настройка"
		1. Команда инициализации проекта: 
				npm init
			Далеьше идет уточняющая информация по проекту: цель, тип проекта, автор ... как и в composer.
			После в проект добавляется файл "package.json" (PJ) с выдачей json объекта с ввдеенной по проекту информацией
		2. //!ВАЖНО: в файле " есть скойство "scripts", которое вмещает в себя скрипт, доступный для запуска через NPM в дальнейшем.  
			Запуск подразумевает ввод свойства скрипта - значением выступает скрипт. 
			"scripts": {
				"test": "echo \"Error: no test specified\" && exit 1"
			},
			Пример запуска: npm run test
			Далее отобразится выплянемый скрипт и затем он выплнится
			//TODO объект script сделан для удобства, чтобы при необходимости работы с несколькими скриптами (их файлами) можно было их вызывать короткой командой. 
		
		3. //TODO Для выполнения кода внутри консоли проекта достаточно пропистаь:
			команда "node run" и адрес файла с запускаемым скриптом => node index.js
			//TODO: вывод в консоль с использованием ` апострофа => 
				console.log(`Число: ${num}`); == console.log('Число: '+num);
		4. Node.js это тот же самый JS, но который можно выполнять где угодно - в том числе внутри проекта. 
			На будущее пропищем в файле "package.json" скрипт: "start": "node index.js"
	*/

	/*Заметки к уроку "#3 – Пакетный менеджер «npm»
		1.  установка библиотеки в проект
		cowsay JavaScript FTW!
				comanda вызова функционала библиотеки
				где,
					cowsay - название библиотеки
					JavaScript FTW - выводимое сообщение с помощью библиотеки в терминале
					//TODO этот карказы вызова функционала библиотеки во всех библиотеках NPM примерно одинаков - сначала в терминале пишется название библиотеки, затем вызывваемая функция/аргумент.
					//!ВАЖНО: чтобы устанавливаемая библиотека заработала - уу нужно установить глобально (с суффиксом -g) на весь компьютер. Иначе она может на работать. 
					Пример удаления библиотеки:
						npm uninstall cowsay
					Прмиер глобальной установки библиотеки:
						npm i -g cowsay
					//TODO при глобальной установки библиотеки - она устанавливается на компьютер, а не локально в проект. Потому так же с компьютера и удаляется. 
					Пример удаления библиотеки с компьютера:
							npm uninstall -g cowsay
		
		2. Подключенгие библиотеки к файлу для использования функциоанала.
		//TODO для вызова функционала библиотеки в файле - после установки ее нужно подключить в файл, где будет вызываться ее функционал. 
			Для этого создается переменная и ей присваиватеся подключение к библиотеки. 
			Пример подключения библиотеки к файлу:
				const convert = require('currency-converter-lt')
			Далее требуется по документации создать объект на основе переменной подключения библиотеки.
				let currencyConverter = new convert({ from: "USD", to: "EUR", amount: 100 })
				Так же во время создания оъекта в класс можно прописать аргументы в виде возможных параметров.
			Когда объект библиотеки создан - можно вызывать ее функционал (конвертирование), а зетем промис - функцию, принимающую ответ от объекта.
			Пример:
				currencyConverter.convert().then((response) => {
					console.log(response) //or do something else
				})
				где,
					currencyConverter - объект библиотеки
					convert() - вызываемый метод 
					then((response) - промис
					console.log(response) //or do something else  - вызов результата
		3. dependencies - зависимости, необходимые для корректной работы всего проекта
			Это зависимость как в conmposer composer.json - она отправляется вместо всех библиотек на проекте
			//TODO при удалении папки с библиотеками node_modules. Они восстанавливаются в проекте при наличии файла package.json и объекта dependencies с библиотеками в нем. 
	*/

	/*Заметки к уроку "#4 – Работа с модулями. Создание модуля"
		В ноде есть множество и своих встроенных модулей помимо устанавливаемых, но так же есть возможность писать свои модули. 
		Шаблон действий работы с встроенным  модулем - примерно аналогичен принципу работы с установленным. 
		//TODO обычно для подключения модулей используют константу "const". 
		1. const os = require('os') - модуль получения информации о ОС пользователя и прочих его данных. 
		2. создание отдельного модуля это создание отдельной папки или файла с последующем его подключением
			Пример подключения:
				const my_math = require('./my_math.js')
		3. обычно подключения называют так же как называется подключаемый модуль/файл. 
		4. //!ВАЖНО! Если обращаться к функциям подключенного файла то будет выдаваться ошибка, функционал подключаемого модуля нужно сделать экспортируемым.
		Пример экспорта модуля:
			1) module.exports.add = add - экспорт одного модуля
			2) module.exports = { - экспорт множества модулей, где 1-й add - псевданим, 2-й add - экспартируемая функция. 
					add: add,
						//или
					minus: (a, b) => {		
						return a - b
					}
				}
		* /

	/*Заметки к уроку "#5 – Работа с файлами"
		1. Подключим модуль для работы с файлами:
			const fs = require('fs')
			//TODO при работе с файлом, которого не существует - этот файл создается в дерриктории
			вызов функци вставки текста в файл: fs.writeFileSync('some.txt', 'Pushed text in file')
				функция полностью переписывает выбранный файл

			чтение файла с определенной кодировкой: let read = fs.readFileSync('some.txt', 'utf-8')
			вызов функци вставки текста в файл с дополнением, а не заменой: fs.writeFileSync('some.txt', read+'\nPushed text in file')				
		2. //!ВАЖНО: суффикс "Sync" в методах "readFileSync" и "writeFileSync" означает НЕАСИНХРОННУЮ ФУНКЦИЮ, а отсутствие этого суффикса означает АСИНХРОННУЮ ФУНКЦИЮ. 
		Это значит, что интерпритатор не будет дожидаться полного выполнения АСИНХРОННОЙ функции перед чтением следующего кода. Это нужно особенно при работе с огромными файлами, чтобы не одной строке кода не стопорился весь процесс чтения. 
		3. //!ВАЖНО: при использовании АСИНХРОННОЙ вариации функции - есть дополнительный параметр (НЕОБАЗАТЕЛЬНЫЙ) в виде замыкания, запускаемого при заврешении работы функции. Он доступен ТОЛЬКО для асинхронных функций.
			ПРИМЕР ЗАПИСИ И ЧТЕНИЯ ФАЙЛА ЧЕРЕЗ КОЛБЕК:
				fs.readFile('some.txt', 'utf-8', (err, data) => {
					fs.writeFile('some.txt', data + '\nPushed text in file')
				})
				где,
					err - ошибка выполнения функции
					data - результата выполенния функции (считананый текст - т.е. return заложенный в функции)
	*/

	/*Заметки к уроку "#6 – Работа с папками"
		1. //! ВАЖНО! Для безопатсности работы с файлами лучше создаватьасинхронными функциями.
		2.	//! ВАЖНО! При выполнении АСИНХРОННЫХ функций без колбека - могут вызникать ошибки при выполнении не смотря на отсутствие ошибок в коде. 	
		3.	Этот вариант создания папки и последующего создания файла возможен только при вызове асинхронных функций
			fs.mkdir('text-files', () => {
				fs.writeFile('./text-files/some.txt', 'Файлс создан+', () => { })
			})
		4.	//! ВАЖНО! При попытки удаления папки - она не удалиться так как перед удалением нужно удалить все содержимое папки. Т.е. без удаления файла в папке - папку не удалить. 
		5.	Пример удаления файла и папки:
			fs.unlink('./text-files/some.txt', () => {
				fs.rmdir('./text-files', () => {
					console.log('Папка и файл удалены')
				})
			})
		6.	//! ВАЖНО! Для удаления файлов используется функиця unlink, а для удаления папок rmdir.
			Но как ранее писалось - сначало удаляется файл, а потом папка. Папка в которой есть файлы - неудаляема. 
	*/

	/*Заметки к уроку "#7 – Создание своего сервера"
	СОЗАДНИЕ СЕРВЕРА	
	Подключим модуль "http" - он отвечает за запуск сервера
		В переменную server заносим метод создания сервера с колбеком запроса и ответа от сервера.
		Через переменную-объект server вызываем метод в который кладем порт и хост сервера и колбек функцию, являющуюся ответом при заходе на сервер. 
		Запуск сервера:
			server.listen(PORT, HOST, () => {
				console.log(`Сервер запущен: http://${HOST}:${PORT}`)
			})
		Команда запуска сервера:
			node|npm index|index.js
		//!ВАЖНО: команда запуска сервера прописывается с полным путем до файла со скриптом запуска. Файл прописывается с форматом так может и без него. 

	ЗАПУСК СЕРВЕРА	
		Сервер запущен, но сервер ничего не делает при открытии - т.е. не открывает страницу. Для перезапуска сервера - из него нужной выйти нажатием ctrl+c. 
			let server = http.createServer((req, res) => {
				res.writeHead('200', { 'Content-Type': 'text/plaine; charset=utf-8' })
				res.end('Выводимый текст')
			})
			где,
				res.writeHead('200', { 'Content-Type': 'text/html; charset=utf-8' }) - отправка заголовков
				где,
					Content-Type - контент
					text/plaine - тип контента
					text/html - тип контента + HTML
					charset=utf-8 - формат текста
				res.end('Выводимый текст') - переданный контент в виде текста
				По адресу "http://localhost:3000/" страница откроется. 
			Отображение HTML кода:
				1) res.end('Выводимый <b>текст</b>') - от бражение HTML
				2) res.end(`<!DOCTYPE html>
					<html lang="en">

					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1.0">
						<title>Node.js - уроки</title>
					</head>

					<body>
						<h1>Выводимый HTML на странице</h1>

						</body>
					</html>`) - от бражение HTML	
				3) Способы подключения HTML файлов рассмотрим в след уроках. 
	*/

	/*Заметки к уроку "#8 – Отслеживание URL. Шаблоны HTML"
		СОЗДАНЕИ ФАЙЛОВ HTML + ИХ АСИНХРОННЫЙ ЗАПУСК 
			Создадим папку и положим в нее шаблон HTML для дальнейшего подключения к созданому серверу.
			res.end - удаляем и подключаем модуль для работы с файлами "fs".
			Подключения модуля для работы с файлами: const fs = require('fs')
			В сервере создаем константу, которая будет открывать HTML файл В ПАТОКЕ!
			Значит файл будет открываться не через fs.readFile,а через fs.createReadStream. readFile - синхронная функция. 
			//!Важно: так как файл будет открываться не просто где то в дериктории и этот файл - html - его нужно запускать в потоке. 
			//TODO функция createReadStream - считывает по-немного указанынй файл и отправляет его на сервер, чтобы пользователь сразу его увидел. 
				Пример:	
					const stream = fs.createReadStream('./templates/index.html')
					stream.pipe(res)
					где,
						createReadStream - метод асинхронного чтения указанного файла
						stream.pipe(res) - метод отправки части прочитанного кода на клиент (это нужно, чтобы клиент не проставивал во время чтения больших файлов)
		
		СОЗДАНИЕ СТИЛЕЙ
			//TODO подключения стилей без express.js не так ужобно, поэтому пропишем стили прямо в файлу HTML в теге style. Подключать стили через expres будут позже. 
		ОТСЛЕЖИВАНИЕ URL АДРЕСОВ
			const http = require('http') - подключение модуля отслеживания URL'ов
			const fs = require('fs') -  подключение модуля работы с файлами
			let server = http.createServer((req, res) => {
				res.writeHead('200', { 'Content-Type': 'text/html; charset=utf-8' })
				if (req.url == '/') {
					fs.createReadStream('./templates/index.html').pipe(res)
				} else if (req.url == '/about') {
					fs.createReadStream('./templates/about.html').pipe(res)
				} else {
					fs.createReadStream('./templates/error.html').pipe(res)
			}

	*/

	/*Заметки к уроку "#9 – Введение в Express JS"
		Библиотека Express JS предоставляет набор удобных функция для работы с сервером. 
		УСТАНОВКА БИБЛИОТЕКИ
			npm i express
		ПОДКЛЮЧЕНИЕ EXPRESS
			const express = require('express')
			const app = express()
		СОЗДАНИЕ GET ЗАПРОСА
			app.get('/', (req, res) => {
				res.send('Выводимый текст через Express')
			})
			Запрос будет работать только при наличии сервера - создадим его
		СОЗДАНЕИ СЕРВЕРА
			const PORT = 3000
			app.listen(PORT, () => {
				console.log(`Сервер запущен по адресу: http://localhost:${PORT}`)
			})
			//TODO  с кодировкой выводимой страницы замарачиваться не проходиться как и с заголовками - все решается через express
		СОЗДАНИЕ ЗАПРОСА С ПАРАМЕТРАМИ
			app.get('/user/:username/:id', (req, res) => {
				res.send(`User ID: ${req.params.id}. User name: ${req.params.username}`)
			})
			где,
				user - endpoint
				username - параметр имени пользователя
				id - параметр айдишник
				:username/:id - объявление параметров
				req, res - запрос/ответ
				params - функция вывода значения парамтера
	*/

	/*Заметки к уроку "#10 – Использование шаблонизатора"
	
	*/

	/*Заметки к уроку "#3 – Установка и настройка"
	
	*/
}